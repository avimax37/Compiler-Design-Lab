- How to run the lex program in the terminal (Ubuntu).
  1. Open the Ubuntu 20.04 LTS (if you are a Windows user) or, terminal (if you are Ubuntu user).
  2. Write, vi <program_name>.l
  3. Update your Ubuntu by, sudo apt-get update.
  4. If you have not installed flex in the Ubuntu, then install flex by, sudo apt install flex.
  5. Open the vim editor and write the code.
  6. Save the code using :wq
  7. Then put the following commands in the terminal,
     lex <program_name>.l
     cc lex.yy.c or, cc lex.yy.c -lfl
     ./a.out
  8. Check out the output and observe that properly.



1. Write a C program which will identify the valid comments.

#include <stdio.h>
#include <string.h>
#include <conio.h>

isValidComment (char str[]){
	if (str[0]=='/' && str[1]=='/' && str[2]!='/'){
		return 1;
	}
	else if (str[0]=='/' && str[1]=='*' && str[strlen(str)-1]=='/' && str[strlen(str)-2]=='*'){
		return 2;
	}
	else {
		return 0;
	}
}

int main(){
	char str[1000];
	printf ("Enter any comment in C Programming language : ");
	scanf ("%[^\n]s",&str);
	if (isValidComment(str)==1){
		printf ("\n\'%s\' is a single line comment in C.", str);
	}
	else if (isValidComment(str)==2) {
		printf ("\n\'%s\' is a multi line comment in C.", str);
	}
	else {
		printf ("\n\'%s\' is not a comment in C.", str);
	}
	return 0;
}



2. Write a C program which will identify the valid identifiers.

#include <stdio.h>
#include <string.h>
#include <conio.h>

int isValidIdentifier (char str[]){
	int i;
	if ((str[0]>='a' && str[0]<='z') || (str[0]>='A' && str[0]<='Z') || str[0] == '_'){
		for (i = 1; i <= strlen(str); i++){
			if ((str[i]>='a' && str[i]<='z') || (str[i]>='A' && str[i]<='Z') || str[i] == '_' || (str[i]>='0' && str[i]<='9')){
				return 1;
			}
		}
	}
	else {
		return 0;
	}
}

int main(){
	char str[1000];
	printf ("Enter any identifier : ");
	scanf ("%[^\n]s",&str);
	if (isValidIdentifier(str)==1){
		printf ("%s is a valid identifier.", str);
	}
	else {
		printf ("%s is not a valid identifier.", str);
	}
	return 0;
}



3. Write a C program which will read a C program, and will delete all the comments.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>

void check_comment (char);
void block_comment ();
void single_comment ();

FILE *fp1, *fp2;

int main(){
	char c;
	fp1 = fopen ("file1.txt","r");
	fp2 = fopen ("MyNewFile.txt","w");
	while ((c=fgetc(fp1))!=EOF){
		check_comment (c);
	}
	fclose (fp1);
	fclose (fp2);
	return 0;
}

// handles both types of comments
void check_comment (char c){
	char d;
	if (c == '/'){
		if ((d = fgetc(fp1))=='*'){
			block_comment();
		}
		else if (d == '/'){
			single_comment ();
		}
		// if both the cases are failed, then we can add the characters in the new file, as they are not comments.
		else {
			fputc (c, fp2);
			fputc (d, fp2);
		}
	}
	// again if both the cases are failed, then we can add the characters in the new file, as they are not comments.
	else{
		fputc (c, fp2);
	}
}

// function to handle the block comments
void block_comment (){
	char d, e;
	// keep reading all the characters of the comment
	while ((d = fgetc(fp1))!=EOF){
		if (d == '*'){
			e = fgetc (fp1);
			// check out whether the comment is ended or, not
			if (e == '/'){ 
				return;
			}
		}
	}
}


// function that handles a single line comment
void single_comment (){
	char d, e;
	while ((d = fgetc(fp1))!=EOF){
		if (d == '\n'){
			fputc ('\n', fp2); // adding a '\n' after the comment ends
			return;
		}
	}
}



4. Write C program which will calculate an arithmetic expression which is 
given as a string. Consider the expression has no paranthesis and contains 
the operators such as, +, -, * and /

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <conio.h>

int stack2[30], temp, length=0, indx=0, pos=0, top=-1;
char symbol, infix[20], postfix[20], stack[30];

void push(char);
void push2(int);
char pop();
int pop2();
int precedence(char);
void infix_to_postfix (char[]);
void eval_postfix(char[]);

void push (char symbol){
	top = top + 1;
	stack[top]=symbol;
}
char pop(){
	temp = stack[top];
	top = top - 1;
	return temp;
}

// providing the priority to the operators while the operation is to be
// going on.
int precedence (char symbol){
	int priority;
	switch(symbol){
		case '#' : {
			priority = 0;
			break;
		}
		case '(' :
		case ')' :{
			priority = 1;
			break;
		}
		case '+' :
		case '-' :{
			priority = 2;
			break;
		}
		case '*' :
		case '/' :{
			priority = 3;
			break;
		}
		case '^' :{
			priority = 4;
			break;
		}
	}
	return priority;
}

void infix_to_postfix (char infix[]){
	length = strlen(infix);
	push ('#');
	while (indx<length){
		symbol = infix[indx++];
		switch (symbol){
			case '(' :{
				push (symbol);
				break;
			}
			case ')' :{
				temp = pop();
				while (temp!='('){
					postfix[pos++] = temp;
					temp = pop();
				}
				break;
			}
			case '-' :
			case '+' :
			case '*' :
			case '/' :
			case '^' :{
				while (precedence(stack[top])>=precedence(symbol)){
					temp = pop();
					postfix[pos++] = temp;
				}
				push (symbol);
				break;
			}
			default :{
				postfix[pos++]=symbol;
				break;
			}
		}
	}
	while (top>0){
		temp = pop();
		postfix[pos++] = temp;
		postfix[pos]='\0';
	}
}

void push2 (int x){
	stack2[++top] = x;
}

int pop2 (){
	return stack2[top--];
}

void eval_postfix (char postfix[]){
	char *temp;
	int n1, n2, n3, num;
	temp = postfix;
	while (*temp!= '\0'){
		if (isdigit(*temp)){
			num = *temp - 48;
			push2 (num);
		}
		else{
			n1 = pop2();
			n2 = pop2();
			switch (*temp){
				case '+' :
					{
						n3 = n1 + n2;
						break;
					}
				case '-' :
					{
						n3 = n2 - n1;
						break;
					}
				case '*' :
					{
						n3 = n1 * n2;
						break;
					}
				case '/' :
					{
						n3 = n2 / n1;
						break;
					}
				case '^' :
					{
						n3 = pow(n2,n1);
						break;
					}
			}
			push2 (n3);
		}
		temp++;
	}
	printf ("\nThe Result of the given expression is %d",pop2());
}

int main (){
	printf ("Enter an Infix Expression : ");
	gets (infix);
	infix_to_postfix(infix);
	printf ("\nThe Postfix Expression will be : ");
	puts (postfix);
	eval_postfix(postfix);
	return 0;
}



5. Write a lex program to count the number of vowels and consonants in a string.

%{
	int vow_count=0;
	int const_count =0;
%}

%%
[aeiouAEIOU] {vow_count++;}
[a-zA-Z] {const_count++;}
%%
int yywrap(){}
int main()
{
	printf("Enter the string of vowels and consonents:");
	yylex();
	printf("Number of vowels are: %d\n", vow_count);
	printf("Number of consonants are: %d\n", const_count);
	return 0;
}



6. Write a LEX program to count the number of words in a string.

%{
int count = 0;
%}

%%
[a-zA-Z0-9]* {count++;}
%%

int yywrap () {}

int main ()
{
printf ("Enter a string: ");
yylex();
printf ("Number of words present in the string is = %d\n", count);
}



7. Write a lex program to count the number of words, digits, characters, lines and special characters in a file.

%{
int word = 0;
int digits = 0;
int spl = 0;
int line = 0;
int temp = 0;
int count = 0;
%}

%%
[a-zA-Z]* {word++; count=count+yyleng;}
[0-9] {digits++;}
\n {line++; word++;}
. {spl++;}
%%

int yywrap () {}

int main()
{
yyin = fopen ("dummy.txt","r");
yylex();
temp = count + spl + digits;
printf ("Number of Words = %d\nNumber of Digits = %d\nNumber of Special Characters = %d\nNumber of Lines = %d\nNumber of Characters = %d\n", word, digits, spl, line, temp);
return 0;
}



8. Write a LEX program which will count the number of scanf and printf statements in a C program, replace them with readf and writef statements respectively.

%{
#include <stdio.h>
int sf=0, pf=0;
%}

%%
"scanf" {sf++; fprintf(yyout, "readf");}
"printf" {pf++; fprintf(yyout, "writef");}
%%

int yywrap()
{
return 1;
}

int main()
{
yyin = fopen("program.c","r");
yyout = fopen("new.c","w");
yylex();
printf ("Number of scanfs = %d\nNumber of printfs = %d\n", sf, pf);
return 0;
}



9. Write a LEX program to count the number of words.

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
%}

%%
([a-z]|[A-Z])* {printf ("%ld", strlen(yytext));}
%%

int main()
{
yylex();
return 0;
}

int yywrap()
{
}



10. Write a LEX program to identify the single line comment and remove it.

%{
#include <stdio.h>
%}

%%
"//"([a-z]|[0-9]|[A-Z]|" ")* {}
%%

int main()
{
yylex();
return 0;
}

int yywrap()
{
}



11. Write a LEX program which will count the number of tokens and also identify them.

%{
int n = 0;
%}

%%
"while"|"if"|"else"|"auto"|"break"|"case"|"char"|"continue"|"do"|"default"|"const"|"double"|"enum"|"extern"|"for"|"goto"|"float"|"int"|"long"|"register"|"return"|"signed"|"static"|"sizeof"|"short"|"struct"|"switch"|"typedef"|"union"|"void"|"volatile"|"unsigned" {n++; printf("\t keywords : %s", yytext);}

[a-zA-Z_][a-zA-Z0-9_]* {n++; printf("\t identifiers : %s", yytext);}
"<="|"=="|"="|"++"|"-"|"*"|"+"|"/" {n++; printf("\t operators : %s", yytext);}
[(){}|, ;] {n++; printf("\t separators : %s", yytext);}
[0-9]+ {n++; printf("\t constant values : %s", yytext);}
%%

int yywrap()
{
return 1;
}

int main()
{
yylex();
printf ("\nTotal number of Tokens : %d\n",n);
}



12. Write a LEX program which will add line numbers to a file. (C program)

%{
int line_no = 1;
%}

line .*\n

%%
{line} {printf ("%10d> %s", line_no++, yytext); }
%%

int yywrap()
{
return 1;
}

int main()
{
yyin = fopen ("program.c", "r");
yylex();
return 0;
}



13. Write a LEX program which will remove multiple spaces, tabs and lines from a user given file.

%{
%}

%%
[ \n\t]+ {fprintf(yyout, "");}
. {fprintf(yyout, "%s", yytext);}
%%

int yywrap()
{
return 1;
}

int main()
{
yyin = fopen("input.txt","r");
yyout = fopen("output.txt","w");
yylex();
return 0;
}



14. Write a YACC program to check the validity of an arithmetic expression that uses the operators such as +, -, * and /

%{
#include<stdio.h>
#include<stdlib.h>
int yylex();
int yyerror();
%}
%token NUM ID
%left '+''-'
%left '*''/'
%%
e:e'+'e
| e'-'e
| e'*'e
| e'/'e
| '('e')'
| NUM
| ID    ;
%%
int main()
{
printf("Type the expression & press enter key.\n");
yyparse();
printf("Valid Expression!\n");
return 0;
}
int yyerror()
{
printf("Invalid Expression :(\n");
exit(0);
}



15. Write a YACC program to implement a basic calculator which can perform basic arithmetic operations.

%{
  #include<stdio.h>
  #include "y.tab.h"
  extern int yylval;
%}

%%
[0-9]+ {
          yylval=atoi(yytext);
          return NUMBER;

       }
[\t] ;

[\n] return 0;

. return yytext[0];

%%

int yywrap()
{
 return 1;
}